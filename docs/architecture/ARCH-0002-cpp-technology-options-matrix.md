# ARCH-0002 — Матрица вариантов технологий/зависимостей для C++

## Статус
- **Назначение документа:** фиксация вариантов (options) и критериев выбора. **Не является решением**.
- **Решения (выбор конкретных библиотек/подходов)** оформляются в как `ADR-*`.

## Цель
Собрать и структурировать варианты технологий/зависимостей для C++ порта (Windows/Linux/macOS), чтобы в можно было принять решения, не нарушая инварианты 1:1 и требования безопасности/эксплуатации.

## Входы
- `docs/requirements/AR-0001-architectural-requirements.md` (требования `REQ-*`)
- `docs/as_is/DEPS-0001-rust-dependencies.md` (роль зависимостей Rust)
- `docs/licensing/POL-0001-third-party-policy.md` (политика third‑party)

## Принципы оценки вариантов (критерии выбора)
> Критерии выводятся из `REQ-*` и `POL-*`; конкретные библиотеки будут выбраны в.

### Must-have критерии (без выполнения — вариант неприемлем)
| Критерий | Источник | Что проверяем на практике |
|---|---|---|
| Эквивалентность 1:1 | `REQ-NFR-0010`, `REQ-NFR-0015`, `REQ-NFR-0016` | Способность библиотеки/подхода воспроизвести байтовые форматы stdout/stderr и содержимое файловых артефактов по golden runs/diff‑harness |
| Детерминизм «внутри платформы» | `REQ-NFR-0011` | Отсутствие скрытой недетерминированности (порядки, тайминги, случайности), возможность стабилизировать вывод без изменения UX |
| Кроссплатформенность Windows/Linux/macOS | `REQ-NFR-0012` | Наличие сборки/поддержки на всех ОС, отсутствие зависимости от Windows-only API для offline‑анализатора |
| Безопасность на недоверенных входах | `REQ-SEC-0017` | Устойчивость к битым EVTX/HVE/ESEDB/MFT/XML/YAML/JSON без падений; отсутствие очевидных ReDoS/DoS рисков |
| Минимизация поверхности атаки | `REQ-SEC-0019` | Отсутствие сетевых/плагинных/скриптовых поверхностей, которые не нужны для 1:1 |
| Лицензия и комплаенс | `REQ-OPS-0026`, `POL-0001` (разд. 6) | OSI‑approved, совместимость с GPLv3 (после проверки), наличие текста лицензии/NOTICE, фиксируемая версия |
| Air‑gapped совместимость | `REQ-OPS-0028` | Возможность собрать и использовать без сетевого доступа в рантайме; управляемое получение зависимостей/датасетов |

### Nice-to-have критерии (влияют на выбор при прочих равных)
- Низкая стоимость интеграции и сопровождения (CMake‑friendly, понятный API, активность проекта).
- Минимальный размер/сложность зависимостей (особенно для консольного инструмента).
- Предсказуемость производительности на больших входах (например, SRUM `SOFTWARE` ~73MB).

---

## Категория A — Парсеры форензик‑форматов (EVTX/HVE/ESEDB/MFT/XML)

### A1. EVTX (offline) → внутреннее представление → JSONL/JSON
**Rust baseline:** crate `evtx` (см. `DEPS-0001`), выход должен совпадать по golden runs.

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий по 1:1 |
|---|---|---|---|---|---|
| libyal **libevtx** | C‑библиотека (FFI) | LGPLv3+ | Готовый парсер EVTX, кроссплатформенная C‑база | Интеграция FFI + управление памятью; возможные отличия семантики (атрибуты/ошибки) относительно Rust; статус upstream может быть «alpha» | Потребуется отдельный слой сериализации/нормализаций, чтобы повторить JSON структуру Rust |
| Собственная реализация EVTX в C++ | Код проекта | n/a (наш код) | Полный контроль формата и ошибок; можно целиться в 1:1 | Высокая стоимость, риск ошибок формата/безопасности | Наиболее прямой путь к 1:1, но дорогой по времени |
| Windows Event Log API (Evt*) | OS API | Proprietary OS API | Может быть удобно на Windows | **Не кроссплатформенно**, ориентировано на live logs, не на одинаковую offline‑семантику | Для целей порта (offline анализ на всех ОС) — сомнительно |

**Открытые вопросы/верификация:**
- Доказать, что выбранный путь может повторить структуру JSON `evtx` crate (включая `_attributes`/спец‑поля) без «улучшений».

### A2. ESEDB (SRUM) → CSV/JSON
**Rust baseline:** crate `libesedb` через `libesedb-sys`.

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| libyal **libesedb** | C‑библиотека (FFI) | LGPLv3+ | Повторяет upstream семейство, вероятно ближе к Rust поведению (Rust уже «обёртка») | Интеграция FFI; возможны отличия трактовки типов/ошибок; сборка на Windows/macOS может потребовать доп. шагов | Наиболее естественный кандидат для 1:1 по SRUM |
| Собственная реализация ESEDB | Код проекта | n/a | Контроль | Очень высокая стоимость и риск | Скорее fallback при невозможности libesedb |
| Windows ESENT API | OS API | Proprietary OS API | Нативная база на Windows | Не кроссплатформенно | Не подходит для общих целей |

### A3. Registry hives (HVE) для `analyse shimcache`
**Rust baseline:** crate `notatin` + сопутствующий код обработки.

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| libyal **libregf** | C‑библиотека (FFI) | LGPLv3+ | Готовый парсер hive; зрелая ниша DFIR | Возможные отличия от `notatin` (особенно транзакционные логи/edge cases); FFI | Подойдёт, если удастся повторить exact вывод shimcache |
| Портировать/переписать семантику `notatin` в C++ | Код проекта | n/a | Максимальный контроль; ближе к Rust, чем замена другим парсером | Стоимость реализации | Вероятно лучший путь для 1:1, если `notatin` сильно влияет на поведение |
| Windows Registry API | OS API | Proprietary OS API | Нативно на Windows | Не кроссплатформенно и не offline‑ориентировано | Не подходит |

### A4. NTFS/MFT и data streams
**Rust baseline:** crate `mft` и логика extraction (см. As‑Is форматы).

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| libyal **libfsntfs** | C‑библиотека (FFI) | LGPLv3+ | Готовая база для NTFS, потенциально полезна и для MFT | Интеграция FFI; может быть избыточна, если нужна только MFT | Может ускорить закрытие MFT‑функций, но нужно сравнение 1:1 |
| Собственная реализация MFT‑парсинга | Код проекта | n/a | Полный контроль форматов и ошибок | Стоимость и риск багов | Реалистичный вариант, если нужен ограниченный функционал |
| SleuthKit | C‑библиотека/набор инструментов | Mixed (CPL/IPL/др.) | Мощный стек DFIR | Тяжёлый стек, неоднородные лицензии и зависимость на утилиты; интеграция/поставка усложняется | Скорее нецелевой для минимального порта |

### A5. XML парсинг (внутренние ветки)
**Rust baseline:** `quick-xml` (в дереве зависимостей встречаются разные версии).

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| pugixml | C++ | MIT | Удобный DOM/SAX, зрелый | Нужно самостоятельно повторить семантику преобразования и ошибок Rust | ОК как парсер, но 1:1 задаётся нашим конвертером |
| tinyxml2 | C++ | zlib | Лёгкий, простой | Ограничения/семантика могут отличаться | Аналогично — нужен слой совместимости |
| expat | C | MIT | Очень распространён | C API, нужна обёртка | Подходит как низкоуровневый парсер |

---

## Категория B — YAML/JSON и Sigma pipeline

### B1. YAML парсер (Sigma rules, mapping файлы)
**Rust baseline:** `serde_yaml` + `yaml-rust`.

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| yaml-cpp | C++ | MIT | Популярный, простой API | Поведение YAML (anchors/merge/tags) может отличаться от Rust; требуется покрыть датасетом Sigma | Требуется отдельная проверка на совместимость с реальными Sigma |
| rapidyaml (ryml) | C++ | MIT | Быстрый, может работать в in‑situ | API/семантика отличны от yaml-cpp; свои edge cases | Аналогично — нужен набор тестов по Sigma |
| libyaml | C | MIT | Базовая реализация, широко упакован | C API и более «низкоуровневый» стиль | Опция, если важна минимальность зависимостей |

### B2. JSON (генерация stdout/out_files + внутренние структуры)
**Rust baseline:** `serde_json`.

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| nlohmann/json | header-only C++ | MIT | Удобен, читаемый код | Производительность/аллокатор; порядок ключей нужно контролировать вручную | Удобен для 1:1 форматирования при небольших объёмах |
| RapidJSON | C++ | MIT | Быстрее, SAX/DOM | Более сложный API | Хорош для streaming JSONL |
| simdjson | C++ | Apache-2.0 или MIT | Очень быстрый парсинг | В основном про parsing; форматирование/генерация — не фокус | Может быть полезен для ускорения чтения крупных JSON |
| Boost.JSON | Boost | BSL-1.0 | Доступен в Boost, без внешних deps | Зависимость на Boost (вес/время сборки) | Опция при использовании Boost в других местах |

### B3. Sigma engine (парсинг detection/condition и применение)
**Rust baseline:** собственная реализация Chainsaw + `tau-engine`.

| Вариант | Класс | Плюсы | Минусы / риски | Комментарий по 1:1 |
|---|---|---|---|---|
| Переписать sigma‑pipeline «как есть» (по Rust исходникам) | Код проекта | Контроль семантики, минимальная внешняя поверхность | Требует портирования логики и точной трактовки модификаторов Sigma | Наиболее прямой путь к 1:1 |
| Использовать стороннюю Sigma‑реализацию (не‑C++) | Внешний runtime | Потенциально быстрее получить функциональность | Добавляет новый runtime (Python/Java), ломает минимизацию поверхности (`REQ-SEC-0019`), высокие риски несовпадения форматов/ошибок | Скорее неприемлемо без отдельного решения |

---

## Категория C — Pattern matching: regex/glob и устойчивость

### C1. Regex engine
**Rust baseline:** crate `regex` + `RegexSet`.

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| RE2 | C++ | BSD-3-Clause | Не подвержен катастрофическому бэктрекингу, есть `RE2::Set` | Возможная дополнительная зависимость (abseil); синтаксис отличается от PCRE | Ближе по ограничениям к Rust `regex` (без backreferences) |
| PCRE2 | C | BSD-3-Clause (style) | Богатый синтаксис | Риск ReDoS при неосторожном использовании; сложность конфигурации | Может дать «лишние» возможности относительно Rust |
| std::regex | STL | стандарт | Нет внешних deps | Реализации и производительность зависят от stdlib; возможны неожиданные различия | Риск недетерминизма/производительности |

### C2. Glob/walkdir
**Rust baseline:** `glob`, `walkdir`.

| Вариант | Класс | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|
| `std::filesystem` + свой glob | STL + код проекта | Минимум deps, полный контроль | Нужно аккуратно повторить поведение glob из Rust | Хороший кандидат, если поведение формализовано тестами |
| Использовать готовую glob‑библиотеку | 3rd‑party | Быстро | Риск отличий в синтаксисе/краевых случаях | Только после сравнения с Rust |

---

## Категория D — CLI, help/usage, вывод в терминал

### D1. Парсинг CLI аргументов
**Rust baseline:** `clap`.

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| CLI11 | C++ | BSD-3-Clause | Удобный API, активный проект | Формат help/errors почти наверняка будет отличаться от clap → нужен слой совместимости | Может использоваться как «движок парсинга», но help/errors — под нашим контролем |
| cxxopts | header-only | MIT | Простой, маленький | Ограничения по функциональности; help формат отличается | Аналогично |
| Boost.Program_options | Boost | BSL-1.0 | Зрелый | Большая зависимость, help формат отличается | Скорее тяжёлый вариант |
| Собственная реализация парсера + генератора help/errors | Код проекта | n/a | Максимальный контроль byte‑to‑byte | Стоимость реализации | Наиболее надёжно для 1:1, если clap формат критичен |

### D2. Цвет/стили/таблицы/прогресс
**Rust baseline:** `colored`, `prettytable-rs`, `indicatif`, `term_size`.

| Подзадача | Вариант | Лицензия | Плюсы | Минусы / риски |
|---|---|---|---|---|
| Цвет в терминале | termcolor (ikalnytskyi) | BSD-3-Clause | Header-only, Windows‑fallback | Поведение ANSI/Windows консоли нужно сверять с Rust output |
| Таблицы | tabulate (p-ranav) | MIT | Готовые таблицы, header-only | Формат таблиц может не совпасть с prettytable-rs |
| Прогресс/спиннеры | indicators (p-ranav) | MIT | Похоже по назначению на indicatif | Нужно сверить формат и управление выводом/перерисовкой |
| «Без libs» | наш код | n/a | Полный контроль 1:1 | Стоимость, риск UX‑различий |

---

## Категория E — Логирование/диагностика (для разработчика)
**Rust baseline:** `log` + `env_logger` (внутреннее).

| Вариант | Класс | Лицензия | Плюсы | Минусы / риски | Комментарий |
|---|---|---|---|---|---|
| spdlog (+ fmt) | C++ | MIT | Богатый функционал, уровни, sinks | Может быть избыточно; важно не «протечь» в пользовательский stdout/stderr | Можно использовать только для dev‑логов (сборка/тесты) |
| fmt + минимальный logger | C++ | MIT | Минимум кода и deps | Меньше готовых features | Для порта CLI‑инструмента часто достаточно |

---

## Категория F — Build/Dependency management/Testing

### F1. Build system
| Вариант | Лицензия | Плюсы | Минусы / риски |
|---|---|---|---|
| CMake | BSD-3-Clause | Де-факто стандарт, кроссплатформен | Требует дисциплины (toolchain files, reproducible builds) |
| Meson | Apache-2.0 | Быстрый/удобный | Экосистема C++ иногда менее стандартна; нужна верификация на Windows/macOS |
| Bazel | Apache-2.0 | Воспроизводимость/кэш | Сложность, выше порог входа |

### F2. Dependency management (в пределах air‑gapped требований)
| Вариант | Лицензия | Плюсы | Минусы / риски |
|---|---|---|---|
| Vendoring (встроить исходники в `third_party/`) | n/a | Максимальная воспроизводимость офлайн, полный контроль версий | Увеличивает репо, нужны процессы обновления и учёт лицензий |
| vcpkg | MIT (инструмент) | Хорошая кроссплатформенность, много портов | Нужен контроль лицензий портов; офлайн режим требует mirror/кэшей |
| Conan | MIT (инструмент) | Гибкий client‑server, подходит для on‑prem | Потребует настройки remotes/кэшей для air‑gapped |
| CPM.cmake / FetchContent | MIT (скрипт) | Просто подключать | **По умолчанию требует сети**; для air‑gapped нужен mirror/архивирование |

### F3. Unit test framework
| Вариант | Лицензия | Плюсы | Минусы |
|---|---|---|---|
| GoogleTest | BSD-3-Clause | Очень распространён, хорошая интеграция с CI | Вес/время сборки |
| Catch2 | BSL-1.0 | Header-friendly, удобные asserts | Может быть тяжелее по compile-time |
| doctest | MIT | Очень лёгкий | Ограничения по возможностям |

---

## Категория G — OS‑абстракции: filesystem, кодировки, время

### G1. Filesystem/path
| Вариант | Класс | Плюсы | Минусы / риски |
|---|---|---|---|
| `std::filesystem` (C++17+) | STL | Стандарт, кроссплатформенно | Нужно аккуратно обработать Windows UTF‑16 ↔ UTF‑8; различия ошибок/сообщений |
| Boost.Filesystem/Nowide | Boost (BSL-1.0) | Решает Windows UTF‑8 API и path | Тяжёлая зависимость на Boost |

### G2. Unicode (UTF‑16/UTF‑8) преобразования
| Вариант | Лицензия | Плюсы | Минусы |
|---|---|---|---|
| WinAPI `WideCharToMultiByte`/`MultiByteToWideChar` (Windows) + ручной код на *nix | OS API + наш код | Прозрачно и нативно | Разные реализации на платформах; нужна единая семантика ошибок |
| ICU | Unicode License | Очень мощно | Тяжёлый стек и данные; может осложнить поставку |
| simdutf | Apache-2.0 или MIT | Быстро, компактно | Зависимость ради узкой задачи |
| utf8cpp | BSL-1.0 | Лёгкая утилита для UTF‑8 | Не решает полностью UTF‑16 ↔ UTF‑8 на Windows |

### G3. Timezone/дата‑время
| Вариант | Лицензия | Плюсы | Минусы / риски |
|---|---|---|---|
| C++20 `std::chrono` tzdb | STL | Стандартный путь | Поддержка tzdb зависит от stdlib/платформ; требуется верификация |
| HowardHinnant/date | MIT | Популярная библиотека, tz поддержка | Нужно решить вопрос поставки/обновления tzdb |

---

## Связь с рисками
- Выбор некоторых категорий напрямую связан с рисками детерминизма и платформенных различий (`RISK-0011`).
- Для shimcache всё ещё отсутствуют входы (SYSTEM hive), что блокирует проверку 1:1 (`RISK-0022`).

## План дальнейших действий
1) На базе этой матрицы выбрать кандидатов и оформить `ADR-*`:
 - обоснование выбора (trade-offs),
 - список third‑party зависимостей с версиями,
 - план лицензирования/NOTICE,
 - план тестов/прототипов для закрытия ключевых рисков.
2) После ADR перейти к To‑Be архитектуре.

---

## Справка: источники лицензий/статусов (для )
> Ссылки приведены для удобства верификации; окончательная проверка совместимости с GPLv3 и включения NOTICE выполняется в –19.

- libyal/libevtx — https://github.com/libyal/libevtx
- libyal/libesedb — https://github.com/libyal/libesedb
- libyal/libregf — https://github.com/libyal/libregf
- libyal/libfsntfs — https://github.com/libyal/libfsntfs
- yaml-cpp — https://github.com/jbeder/yaml-cpp
- rapidyaml (ryml) — https://github.com/biojppm/rapidyaml
- nlohmann/json — https://github.com/nlohmann/json
- RapidJSON — https://github.com/Tencent/rapidjson
- simdjson — https://github.com/simdjson/simdjson
- RE2 — https://github.com/google/re2
- PCRE2 — https://github.com/PCRE2Project/pcre2
- CLI11 — https://github.com/CLIUtils/CLI11
- cxxopts — https://github.com/jarro2783/cxxopts
- fmt — https://github.com/fmtlib/fmt
- spdlog — https://github.com/gabime/spdlog
- tabulate — https://github.com/p-ranav/tabulate
- indicators — https://github.com/p-ranav/indicators
- termcolor — https://github.com/ikalnytskyi/termcolor
- Catch2 — https://github.com/catchorg/Catch2
- GoogleTest — https://github.com/google/googletest
- CMake — https://cmake.org/
- vcpkg — https://github.com/microsoft/vcpkg
- Conan — https://github.com/conan-io/conan
- CPM.cmake — https://github.com/cpm-cmake/CPM.cmake
- HowardHinnant/date — https://github.com/HowardHinnant/date
- simdutf — https://github.com/simdutf/simdutf
