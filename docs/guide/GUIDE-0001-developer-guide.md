# GUIDE-0001 — Практическое руководство разработчика (Chainsaw Rust → C++ порт)

## Статус
- Версия: 1
- Статус: Draft (To‑Be)

## Назначение
Документ фиксирует **проверяемые правила разработки** C++ порта Chainsaw, чтобы:
- обеспечить эквивалентность наблюдаемого поведения **1:1** (см. `GOV-0002`);
- поддержать кроссплатформенность Windows/Linux/macOS;
- снизить риски, связанные с недоверенными входами и платформенными различиями;
- сделать последующую реализацию и ревью воспроизводимыми.

## Входы (Single Source of Truth)
- Требования `REQ-*`: `docs/requirements/AR-0001-architectural-requirements.md`.
- Архитектурные решения `ADR-*`: `docs/adr/ADR-0001...ADR-0011`.
- To‑Be архитектура и модульные границы `MOD-*`: `docs/architecture/TOBE-0001-cpp-to-be-architecture.md`.
- Критерии 1:1: `docs/governance/GOV-0002-equivalence-criteria.md`.
- Правила SoT/трассируемости: `docs/governance/GOV-0001-traceability-and-sot.md`.
- Политика third-party и данных: `docs/licensing/POL-0001-third-party-policy.md`.

> Важно: этот документ не дублирует формулировки `REQ-*` и не заменяет ADR. Он задаёт **инженерные нормы** и «как проверять соответствие».

---

## 0) Базовые инварианты разработки

### 0.1. Инварианты результата
1) **Эквивалентность 1:1 первична**.
 - Любое изменение, влияющее на stdout/stderr/exit code/файлы вывода, должно иметь доказательство по `GOV-0002` (сценарии `RUN-*`, отчёты `REP-*`, test‑to‑test `TST-*`).
	 - Запрещены «улучшения» поведения/форматов, не требуемые baseline (`TASK-0001`, `REQ-NFR-0016`).

2) **Детерминизм важнее параллелизма** (`ADR-0011`, `REQ-NFR-0011`, `REQ-NFR-0015`).

3) **Входы недоверенные** (`REQ-SEC-0017`, `REQ-SEC-0022`).
 Любой файл/строка/путь/правило/EVTX/YAML/JSON рассматриваются как потенциально вредоносные.

4) **Кроссплатформенность достигается через изоляцию платформенных деталей** (см. `TOBE-0001`, модуль `MOD-0004 platform`).

### 0.2. Языки и тексты
- Все **репозиторные документы** и комментарии — на русском.
- Пользовательский вывод CLI (help/errors/таблицы/JSON и т.п.) **не переводится** и воспроизводится 1:1 относительно baseline Rust (см. `ADR-0006`).

---

## 1) Сборка, тесты и локальный цикл (REQ-OPS-0023)

> Цель: зафиксировать единый воспроизводимый способ `configure → build → test` (детали реализуются в ).

### 1.1. Нормативные команды (должны поддерживаться проектом)

**Single-config генераторы (Ninja/Unix Makefiles):**
```bash
cmake -S cpp -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
ctest --test-dir build --output-on-failure
```

**Multi-config генераторы (Visual Studio/Xcode):**
```bash
cmake -S cpp -B build
cmake --build build --config Release
ctest --test-dir build -C Release --output-on-failure
```

### 1.2. Правила
- **G-001:** В `cpp/` должен быть корень CMake проекта (`CMakeLists.txt`).
 - Проверка: файл существует; команды из 1.1 выполняются.
- **G-002:** Сборка по умолчанию не должна требовать сети (`ADR-0002`, `REQ-OPS-0028`).
 - Проверка: сборка из чистого состояния проходит в окружении без сети.
- **G-003:** Все тесты запускаются через `ctest` (см. `ADR-0008`).
 - Проверка: `ctest` обнаруживает и исполняет тесты.

---

## 2) Структура репозитория и модульные границы

### 2.1. Каталоги
- `cpp/` — код порта.
- `docs/` — документы (SoT по `GOV-0001`).
- `third_party/` — vendored зависимости и тексты лицензий (`ADR-0002`, `POL-0001`).
- `tools/` — harness/скрипты доказательной инфраструктуры.

### 2.2. Модули `MOD-*` как границы ответственности
- Реализация должна следовать границам `MOD-*` из `TOBE-0001`.

**Правила:**
- **G-010:** Платформенная специфика (OS API, кодировки, различия Windows/Unix) допускается только в `MOD-0004 platform` и строго необходимых местах с явной причиной.
 - Проверка: code review + поиск `#ifdef` вне `platform`.
- **G-011:** Запрещено писать в stdout/stderr напрямую из модулей, кроме `MOD-0003 output` и точки входа `MOD-0001 app` (где создаётся writer).
 - Проверка: поиск `std::cout|std::cerr|printf|fprintf\(stderr` вне `output/app`.
- **G-012:** Каждый файл реализации модуля должен содержать ссылку на `MOD-XXXX` (в шапке файла или в комментарии рядом с namespace).
 - Проверка: grep по `MOD-` в `cpp/`.

---

## 3) Стандарт C++ и базовые правила кода (ADR-0001)

### 3.1. Стандарт языка
- **G-020:** Базовый стандарт — **C++17** (`ADR-0001`).
 - Проверка: настройки CMake/CI; отсутствие требуемых фич C++20+.

### 3.2. Безопасность памяти и RAII
- **G-021:** Запрещены ручные `new/delete` в прикладной логике. Использовать RAII и стандартные контейнеры/умные указатели.
 - Проверка: code review + grep `\bnew\b|\bdelete\b` (исключение — изолированные low-level адаптеры при необходимости).
- **G-022:** Любые размеры/длины, приходящие снаружи, валидируются до выделений памяти и индексации (`REQ-SEC-0022`).
 - Проверка: ревью критических парсеров + sanitizers/анализ (/39).

### 3.3. Exception safety и границы ошибок
Цель: ошибки должны быть **управляемыми** и не разрушать 1:1 вывод.

- **G-023:** Не допускается «самопроизвольная» печать ошибок библиотеками/утилитами. Все пользовательские ошибки формируются в `cli/output` согласно `ADR-0006`.
 - Проверка: ревью; отсутствие `std::terminate`/необработанных исключений на пользовательских сценариях.
- **G-024:** Любые исключения (если используются) перехватываются на границе `MOD-0001 app` и преобразуются в диагностический результат (exit code + stderr bytes), совместимый с baseline.
 - Проверка: наличие `try/catch` на верхнем уровне; тесты/`RUN-*` на ошибочные сценарии.

---

## 4) Пользовательский вывод, форматы и детерминизм (ADR-0006/0007/0011)

### 4.1. CLI/help/errors/таблицы
- **G-030:** Help/usage/errors — часть наблюдаемого поведения и реализуются собственным слоем CLI (`ADR-0006`).
 - Проверка: дифф‑harness по `..` (/33).
- **G-031:** Форматирование строк выполняется через `fmt` (`ADR-0007`), но финальные строки должны совпадать с baseline.
 - Проверка: golden runs/diff.

### 4.2. Правило «байты первичны»
- **G-032:** Внутренний слой вывода оперирует байтами (строки + `\n`), избегает `std::endl` и локаль‑зависимых форматирований.
 - Проверка: ревью; отсутствие `std::endl`; повторяемость `RUN-*`.

### 4.3. Детерминизация порядка
- **G-033:** Любой наблюдаемый порядок результатов должен быть детерминирован.
 - Примеры: порядок перечисления файлов, порядок детектов, порядок строк таблиц.
 - Проверка: повторные прогоны (`GOV-0002/C7`), тесты стабильности.

---

## 5) Пути, файловая система, кодировки (ADR-0010)

### 5.1. Единый тип
- **G-040:** `std::filesystem::path` — единственный тип путей в реализации (`ADR-0010`).
 - Проверка: code review.

### 5.2. Единая политика преобразований
- **G-041:** Преобразования `path ⇄ UTF‑8 string` выполняются только через единый слой `platform::paths` (или эквивалентный модуль в `MOD-0004 platform`).
 - Проверка: отсутствие прямых `path.string/u8string` в бизнес‑логике.

### 5.3. Безопасное создание файлов
- **G-042:** Любая генерация путей вывода должна защищаться от path traversal (`REQ-SEC-0021`).
 - Проверка: unit/security тесты + ревью.

---

## 6) Обработка недоверенных входов (SEC)

Цель: порт не должен падать/входить в UB на битых данных.

- **G-050:** Для всех форматов (EVTX/YAML/JSON/ESEDB/HVE/MFT/XML) ошибки парсинга — контролируемые: возвращается диагностическая ошибка, соответствующая baseline, либо «skip» поведение при `--skip-errors` согласно `DATA-0001`.
 - Проверка: `RUN-*`/`TST-*` негативные кейсы.
- **G-051:** Ограничивать ресурсы на недоверенных входах (глубина рекурсии, размер буферов, количество записей) там, где это необходимо для предотвращения DoS, без изменения baseline поведения (при расхождении — оформлять как риск/решение).
 - Проверка: security tests + отдельные фикстуры.

---

## 7) Зависимости и лицензии (ADR-0002, POL-0001)

- **G-060:** Любая новая зависимость оформляется управляемо:
 1) запись в `docs/licensing/LIC-0002-cpp-dependencies.md`;
 2) добавление текста лицензии/NOTICE в `third_party/licenses/` (если применимо);
 3) фиксация версии/commit/tag и checksum;
 4) проверка офлайн‑сборки.
 - Проверка: аудит лицензий + ревью PR.

- **G-061:** По умолчанию зависимости вендорятся в репозиторий (`ADR-0002`), FetchContent/сеть — только опционально и не для CI.
 - Проверка: сборка без сети.

---

## 8) Тестирование и доказательства 1:1 (REQ-NFR-0010, GOV-0002)

### 8.1. Test‑to‑test
- **G-070:** Перенос тестов выполняется по `TESTMAT-0001`: каждый `TST-*` должен иметь C++ эквивалент.
 - Проверка: обновление `TESTMAT-0001` + наличие тестов в `cpp/tests`.

- **G-071:** В имени теста или файла должен присутствовать `TST-XXXX`.
 - Проверка: grep `TST-` в `cpp/tests`.

### 8.2. Golden runs / diff harness
- **G-072:** Любые изменения, влияющие на e2e поведение, подтверждаются дифф‑harness отчётом `REP-*`.
 - Проверка: наличие `REP-*` и регистрация в.

### 8.3. Повторяемость
- **G-073:** Для сценариев, помеченных как repeats, должны выполняться повторы (3+ запусков) и совпадение результатов (`GOV-0002/C7`).
 - Проверка: отчёты прогонов.

---

## 9) Чистота репозитория и артефактов (REQ-OPS-0029)

- **G-080:** Запрещено коммитить/паковать локальное состояние и результаты сборок/прогонов: `.local/`, `build/`, `out/`, `inputs/raw/`, `inputs/extracted/`, `inputs/tmp/`.
 - Проверка: `.gitignore` + ревью ZIP‑снапшотов.

- **G-081:** Любой значимый новый артефакт (документ/скрипт/отчёт/архив) регистрируется в как `ART-*` (`GOV-0001`).
 - Проверка: наличие записи.

---

## 10) Как вносить изменения (минимальный процесс)

1) Определить, какие `REQ-*`, `ADR-*`, `MOD-*`, `TST-*` и/или `RUN-*` затрагиваются.
2) Реализовать изменение в пределах соответствующего модуля `MOD-*`.
3) Добавить/обновить тесты (`TST-*`) и/или сценарии/отчёты (`RUN-*`/`REP-*`).
4) Обновить трассировку при изменении структуры доказательств.
5) Если появляется неопределённость — зафиксировать `RISK-*` с планом закрытия.

---

## 11) Quality gates

Инструменты автоматического контроля качества интегрированы и документированы в `POL-0002-green-state-policy.md`.

### 11.1. Форматирование (clang-format)
- Конфигурация: `cpp/.clang-format`
- Базовый стиль: Google, адаптированный для проекта
- Команды:
 - `cmake --build build --target format` — форматирование
 - `cmake --build build --target format-check` — проверка без изменений

### 11.2. Статический анализ (clang-tidy)
- Конфигурация: `cpp/.clang-tidy`
- Включённые проверки: bugprone, clang-analyzer, concurrency, cppcoreguidelines (частично), misc, modernize, performance, portability, readability
- Интеграция: `-DCHAINSAW_ENABLE_CLANG_TIDY=ON`

### 11.3. Санитайзеры
- Конфигурация: `cpp/cmake/Sanitizers.cmake`
- Доступные санитайзеры:
 - `address` (ASan) — buffer overflow, use-after-free, memory leaks
 - `undefined` (UBSan) — undefined behavior
 - `thread` (TSan) — data races
 - `memory` (MSan) — uninitialized memory (только Clang)
- Использование: `-DCHAINSAW_SANITIZER=address`

### 11.4. Правило «зелёного» состояния
- **G-100:** Код считается ready-to-merge только если:
 - Сборка успешна на 3 платформах (Linux/macOS/Windows)
 - Все тесты проходят (`ctest`)
 - Санитайзеры не выявляют нарушений (ASan, UBSan)
 - Проверка: см. чек-лист в `POL-0002`
