# CLI-0001 — CLI-контракт Chainsaw (Rust) As‑Is

## Цель
Зафиксировать наблюдаемый **CLI‑контракт** upstream Chainsaw (Rust) в форме, пригодной для 1:1 портирования в C++:
- команды/подкоманды;
- параметры/флаги/дефолты;
- коды возврата (exit codes);
- каналы вывода (stdout/stderr), форматы вывода;
- классы ошибок и характерные сообщения.

## Объём (Scope)
В документе фиксируется только внешний контракт CLI (то, что пользователь видит/получает на stdin/stdout/stderr и через exit code).

Не фиксируются (в рамках ):
- внутренняя архитектура Rust и потоки данных;
- детальные спецификации форматов входных данных и трансформаций;
- перечень фич продукта целиком;
- любые To‑Be решения/выбор библиотек (после завершения As‑Is и ).

## Baseline
Baseline upstream‑версии зафиксирован в документе `BASELINE-0001`. Этот CLI‑контракт относится к тому же baseline (``).

## Источники (primary)
- `/src/main.rs` — определение CLI через `clap` (Parser/Subcommand) и реализация команд в `run` + обработка ошибок/exit code в `main`.
- `/src/write.rs` — макросы вывода (`cs_*`), разделение stdout/stderr, поведение `quiet` и `verbose`, запись в файл через `--output`.
- `/src/cli.rs` — platform‑dependent детали интерфейса (префиксы/спиннер/прогрессбар).
- `/src/file/mod.rs` — рекурсивный сбор файлов и фильтрация по расширениям.
- `/src/rule/mod.rs` — допустимые значения для `--kind/--level/--status` и сообщения об ошибках парсинга.
- `/tests/clo.rs` + ожидаемые файлы `/tests/**.txt` — примеры реальных CLI‑вызовов и подтверждение успешного exit‑кода для отдельных сценариев.

## Источники (secondary)
- `/README.md` — описания/примеры использования. Используется только как справка; при противоречии приоритет у кода.

---

# 1. Общий контракт CLI

## 1.1. Имя бинаря, описание, стандартные флаги
- Имя команды: `chainsaw`.
- `about`: `Rapidly work with Forensic Artefacts`.
- Примеры в `after_help` вшиты в CLI‑help.

Источник: `/src/main.rs:24-56`.

Стандартные флаги, которые генерирует `clap` (по умолчанию для derive‑Parser):
- `-h/--help`
- `-V/--version`

> Примечание: точный формат вывода `--help/--version` является частью наблюдаемого поведения, но в текущем шаге подтверждается только статическим анализом (см. Unknowns).

## 1.2. Глобальные опции
Глобальные опции применимы ко всем подкомандам:

- `--no-banner` — скрыть ASCII‑баннер.
- `--num-threads <N>` — ограничить количество потоков Rayon (по умолчанию: количество CPU).
- `-v` (повторяемый) — уровень подробности вывода (счётчик).

Источник: `/src/main.rs:44-56`, применение `num_threads`: `/src/main.rs:401-407`.

## 1.3. Разделение stdout/stderr и перенаправление в файл
### 1.3.1. Каналы
- Данные результатов (YAML/JSON/JSONL/таблицы) пишутся через `cs_print*` (stdout или файл при `--output`).
- Информационные сообщения (`[+]...`, `[!]...`) пишутся через `cs_eprintln*` (stderr) и могут подавляться `-q`.

Источник:
- вывод в stdout/файл: `/src/write.rs:63-103`, `132-183`;
- подавление stderr при `quiet`: `/src/write.rs:123-130`.

### 1.3.2. `--output`
- Если указан `--output <path>` и формат **не CSV** (см. ниже) — файл создаётся/перезаписывается.
- При невозможности создать файл — команда завершается ошибкой `Unable to write to specified output file - <path> - <err>`.

Источник: `/src/main.rs:356-399`.

### 1.3.3. CSV как «директория вывода»
Для режимов, где CSV подразумевает набор файлов/сложный вывод, `--output` интерпретируется как путь (ожидаемо — директория), а не как единичный файл.

Источник: логика `csv => (Some(path), None)` в `init_writer`: `/src/main.rs:356-389`.

## 1.4. `-q` (quiet) и `-v` (verbose)
- `-q` подавляет **информационный stderr** (все `cs_eprintln!`), но не влияет на stdout‑результаты.
- `-v` влияет на отладочный stderr (`cs_debug!` при `verbose>0`, `cs_trace!` при `verbose>1`).

Источник: `/src/write.rs:105-130`.

## 1.5. Прогресс‑бар и platform‑dependent элементы
- Префикс правил в табличном выводе:
 - non‑Windows: `RULE_PREFIX = "‣"`
 - Windows: `RULE_PREFIX = "+"`
- Символы спиннера и частота тиков отличаются на Windows vs non‑Windows.
- Прогресс‑бар по умолчанию пишет в stderr и скрывается:
 - если `verbose!= 0` (глобальный `-v`),
 - или если `quiet == true`.

Источник: `/src/cli.rs:25-70`.

## 1.6. Exit codes и формат ошибок
### 1.6.1. Ошибка выполнения (runtime error)
Если `run` возвращает ошибку, `main` печатает сообщение в stderr с префиксом `[x]` и завершает процесс с кодом `1`.

Источник: `/src/main.rs:1152-1160`.

Формат:
- если есть `cause` (вторая ошибка в цепочке): `[x] <err> - <cause>`
- иначе: `[x] <err>`

Источник: `/src/main.rs:1153-1158`.

### 1.6.2. Успех
Для проверенных CLI‑сценариев (тесты Rust) код завершения = `0`.

Источник: `/tests/clo.rs:6-145` (используется `.success`).

### 1.6.3. Ошибки парсинга аргументов `clap`
Поведение (сообщения/exit code) задаётся `clap` и требует подтверждения через реальные запуски (см. Unknowns).

---

# 2. Подкоманды

## 2.1. `dump` — дамп артефактов в другой формат

### Назначение
Прочитать поддерживаемые «forensic artefacts» (файлы/директории) и вывести документы в YAML/JSON/JSONL.

Источник: описание и ветка `Command::Dump`: `/src/main.rs:58-94`, `401-519`.

### Аргументы
- `path: Vec<PathBuf>` — один или несколько путей (файлы/директории).

Источник: `/src/main.rs:60-64`.

### Опции
- `-j, --json` — JSON array (см. формат ниже).
- `--jsonl` — JSON Lines.
- `--load-unknown` — пытаться грузить неизвестные типы.
- `--extension <ext>` — фильтр по расширению (одна строка).
- `-o, --output <path>` — писать результат в файл.
- `-q` — подавить informational stderr.
- `--skip-errors` — продолжать при ошибках.

MFT‑specific:
- `--decode-data-streams`
- `--data-streams-directory <dir>`

Источник: `/src/main.rs:60-94`.

### Фильтрация по расширению
- `--extension` сравнивается со значением `Path::extension` (без точки), т.е. ожидается ввод вида `evtx`, `json`, `yaml` и т.п.

Источник: формирование `HashSet::from([extension])`: `/src/main.rs:441-444`; сравнение по `path.extension`: `/src/file/mod.rs:479-488`.

### Форматы вывода
- По умолчанию: YAML; перед каждым документом печатается строка `---`.
- `--json`: вывод начинается с `[`; каждый документ печатается pretty‑JSON, элементы разделяются `,\n`, вывод заканчивается `]`.
- `--jsonl`: каждый документ печатается как JSON‑объект на отдельной строке.

Источник: `/src/main.rs:435-519`.

### Информационный вывод (stderr)
Типичные сообщения:
- `[+] Dumping the contents of forensic artefacts from:... (extensions:...)`
- `[+] Loaded <N> forensic artefacts (<size>)`
- `[+] Done`

Источник: `/src/main.rs:422-519`.

### Ошибки
- Пустой набор файлов после фильтрации: `No compatible files were found in the provided paths`.
- Ошибка создания `--output` файла: `Unable to write to specified output file -...`.

Источник: `/src/main.rs:356-399`, `452-455`.

---

## 2.2. `hunt` — применение правил детекта

### Назначение
Загрузить правила (Chainsaw rules и/или Sigma rules), загрузить артефакты и выполнить «охоту» (детект) с формированием вывода.

Источник: описание и ветка `Command::Hunt`: `/src/main.rs:96-189`, `520-810`.

### Аргументы
- `rules: Option<PathBuf>` — путь к коллекции правил (опционально).
- `path: Vec<PathBuf>` — пути к артефактам для обработки.

Источник: `/src/main.rs:96-103`.

### Важная особенность: перегрузка позиционного `rules`
Если указаны `-r/--rule` или `-s/--sigma`, то позиционный `rules`, если он задан, трактуется как **дополнительный путь артефактов** (добавляется в `path`), а не как источник правил.

Источник: `/src/main.rs:570-579`.

### Опции правил
- `-m, --mapping <path>` (может повторяться) — mapping для third‑party rules.
- `-r, --rule <path>` (может повторяться) — дополнительные rules.
- `-s, --sigma <path>` (может повторяться) — Sigma rules; **требует** `--mapping`.
- `--kind <chainsaw|sigma>` (может повторяться) — фильтр вида правил.
- `--level <critical|high|medium|low|info>` (может повторяться) — фильтр уровней.
- `--status <stable|experimental>` (может повторяться) — фильтр статусов.

Источник: `/src/main.rs:104-188`; допустимые значения: `/src/rule/mod.rs:105-205`.

### Опции артефактов / времени
- `--extension <ext>` (может повторяться) — ограничение по расширениям.
- `--load-unknown` — принудительно грузить неизвестные типы.
- `--from/--to <YYYY-MM-ddTHH:mm:SS>` — ограничение по времени.
- `--local` или `--timezone <TZ>` — форматирование времени.

Источник: `/src/main.rs:125-188`.

### Опции вывода
- Форматы: (по флагам)
 - default: табличный вывод (prettytable);
 - `--json`;
 - `--jsonl`;
 - `--csv` (требует `--output`);
 - `--log`.
- `--column-width <N>` — ширина колонок (не совместима с `--json`).
- `--full` — печатать полные значения (не совместима с `--json`).
- `--metadata` — печать доп.метаданных (не совместима с `--json`).
- `-o, --output <path>` — файл/директория для результатов.
- `-q` — подавить informational stderr.

Источник: `/src/main.rs:111-168`.

### `--csv` требует директорию
Если `--csv` и `--output` указывает на существующий файл, команда завершается ошибкой `Unable to create output directory`.

Источник: `/src/main.rs:551-565`.

### `--cache-to-disk`
- `-c/--cache-to-disk` требует `--jsonl` и конфликтует с `--json`.

Источник: `/src/main.rs:111-118`.

### Итоговое сообщение
В конце печатается (stderr): `\n[+] <hits> Detections found on <documents> documents`.

Источник: `/src/main.rs:809-810`.

---

## 2.3. `lint` — проверка правил

### Назначение
Проверить, что правила загружаются корректно. Опционально вывести tau‑логику.

Источник: описание и ветка `Command::Lint`: `/src/main.rs:191-201`, `811-872`.

### Аргументы
- `path: PathBuf` — путь к коллекции правил.

Источник: `/src/main.rs:191-200`.

### Опции
- `--kind <chainsaw|sigma>` — тип правил для линтинга.
- `-t, --tau` — вывести tau‑представление.

Источник: `/src/main.rs:191-201`; допустимые значения kind: `/src/rule/mod.rs:127-137`.

### Вывод и ошибки
- stderr: стартовое сообщение `[+] Validating as <kind> for supplied detection rules...`.
- При ошибке загрузки конкретного файла: `[!] <relative_or_full_path>: <err>` (stderr) и продолжение обработки.
- В конце: `[+] Validated <ok> detection rules out of <total>` (stderr).

Источник: `/src/main.rs:816-871`.

---

## 2.4. `search` — поиск по артефактам

### Назначение
Искать по артефактам ключевые строки, regex‑паттерны или tau‑выражения.

Источник: описание и ветка `Command::Search`: `/src/main.rs:203-270`, `873-1043`.

### Аргументы
- `pattern: Option<String>` — строка/regex паттерн; **обязателен**, если не указан `-e/--regex` или `-t/--tau`.
- `path: Vec<PathBuf>` — пути к артефактам; если не заданы, используется текущая директория.

Источник: `/src/main.rs:205-212`, дефолт current dir: `/src/main.rs:909-913`.

### Опции
- `-e, --regex <pattern>` (может повторяться) — дополнительные строковые/regex‑паттерны.
- `-t, --tau <expr>` (может повторяться) — tau‑выражения; множественные условия по умолчанию AND, при `--match-any` — OR.
- `-i, --ignore-case` — case‑insensitive.
- `--match-any` — семантика OR для множества паттернов.
- `--extension <ext>` (может повторяться) — фильтр расширений.
- `--load-unknown`
- `--skip-errors`
- `--timestamp <field>` — имя поля времени.
- `--from/--to <YYYY-MM-ddTHH:mm:SS>` — требуют `--timestamp`.
- `--local` или `--timezone <TZ>`.
- `-j, --json` — JSON array.
- `--jsonl` — JSON Lines.
- `-o, --output <path>` — вывод в файл.
- `-q` — подавить informational stderr.

Источник: `/src/main.rs:213-269`.

### Форматы вывода
- По умолчанию: YAML. Каждый hit предваряется `---`.
- `--json`: вывод начинается с `[`; каждый hit печатается как **compact JSON**, элементы разделяются `,` (без перевода строки), вывод завершается `]`.
- `--jsonl`: каждый hit — JSON‑объект на отдельной строке.

Источник: `/src/main.rs:983-1038`.

### Параллельная обработка
Поиск выполняется в `files.par_iter` (Rayon). Это потенциально влияет на порядок результатов при множестве файлов.

Источник: `/src/main.rs:990-1034`.

### Итоговое сообщение
В конце печатается (stderr): `[+] Found <N> hits`.

Источник: `/src/main.rs:1039-1042`.

---

## 2.5. `analyse shimcache`

### Назначение
Создать execution timeline по shimcache с опциональным обогащением из amcache.

Источник: `/src/main.rs:279-305`, `1046-1089`.

### Аргументы
- `<shimcache>` — путь к SYSTEM hive.

Источник: `/src/main.rs:283-285`.

### Опции
- `-e, --regex <pattern>` (может повторяться)
- `-r, --regexfile <path>` — файл с regex, по одному паттерну в строке.
- `-o, --output <path>` — выходной CSV.
- `-a, --amcache <path>` — путь к Amcache.hve.
- `-p, --tspair` — требует `--amcache`.

Источник: `/src/main.rs:286-305`.

### Вывод
- Данные выводятся в CSV (`init_writer(..., csv=true,...)`).
- Если указан `--regexfile`: stderr сообщение о количестве паттернов и canonical path.
- Если указан `--output`: stderr сообщение `Saved output to...`.

Источник: `/src/main.rs:1057-1088`.

---

## 2.6. `analyse srum`

### Назначение
Разобрать SRUM database и вывести таблицы/содержимое.

Источник: `/src/main.rs:306-322`, `1090-1145`.

### Аргументы
- `<srum_path>` — путь к SRUDB.dat.
- `-s, --software <path>` — путь к SOFTWARE hive (**обязателен**).

Источник: `/src/main.rs:308-313`.

### Опции
- `--stats-only` — вывести только сведения о таблицах.
- `-q` — подавить informational stderr.
- `-o, --output <path>` — сохранить JSON в файл.

Источник: `/src/main.rs:313-322`.

### Вывод
- Без `--stats-only`: печатает table details + JSON содержимое БД.
- С `--stats-only`: печатает только table details.
- При `--output`: печатает сообщения `Saving output to...` и `Saved output to...` и пишет JSON в файл.

Источник: `/src/main.rs:1104-1141`.

### Ошибки
Ошибки `parse_srum_database` печатаются как `[!] Error parsing SRUM database:...`, но не приводят к `return Err(...)` в этой ветке.

Источник: `/src/main.rs:1102-1144`.

---

# 3. Зафиксированные несоответствия README ↔ код

1) `dump --extension`:
- README описывает множественные расширения (`<extension>...`),
- код определяет `extension: Option<String>` (одно значение).

Источник: README (в `/README.md`) vs код `/src/main.rs:74-76`.

2) `lint --kind`:
- help‑строка в коде говорит `chainsaw, sigma or stalker`,
- фактически `RuleKind` поддерживает только `chainsaw`/`sigma`.

Источник: `/src/main.rs:195-200` vs `/src/rule/mod.rs:105-137`.

3) `search` и группа форматов:
- `--jsonl` помечен как `group = "format"`,
- `--json` не входит в группу.

Источник: `/src/main.rs:232-237`.

---

# 4. Unknowns / вопросы, требующие подтверждения

> Формат: `CLI-UNKN-xxxx` — неопределённость, которая может повлиять на 1:1 порт.

- **CLI-UNKN-0001 — точные тексты `--help`/`--version` и exit code при ошибках парсинга аргументов.**
 - Причина: в Projects‑среде отсутствует Rust toolchain (`cargo`), невозможно воспроизвести `chainsaw --help`.
 - План подтверждения: golden runs — снять `--help/--version` и сценарии ошибок (неизвестная команда/флаг, missing required arg) с фиксацией stdout/stderr/exit code.

- **CLI-UNKN-0002 — минимальное число значений для позиционных `Vec<PathBuf>` (например, `dump <path...>` / `hunt <path...>`).**
 - Причина: поведение определяется `clap` (минимум 1 или 0), статическим анализом гарантировать нельзя.
 - План подтверждения: — запуски с отсутствующими позиционными аргументами и фиксация поведения.

- **CLI-UNKN-0003 — точная семантика `ArgGroup` (`group = "format"`) для взаимного исключения форматов.**
 - Причина: семантика enforced на уровне `clap`.
 - План подтверждения: — попытка указать взаимоисключающие комбинации (`--json --csv`, `--json --jsonl` и т.д.) и фиксация ошибки/exit code.

- **CLI-UNKN-0004 — exit code при `analyse srum` в случае ошибки парсинга SRUM.**
 - Наблюдение: код печатает ошибку, но не возвращает `Err`.
 - План подтверждения: — запустить `analyse srum` на заведомо некорректном входе и зафиксировать exit code.

- **CLI-UNKN-0005 — детерминизм порядка результатов `search` при множестве файлов.**
 - Наблюдение: используется `files.par_iter`.
 - План подтверждения: — повторные прогоны на каталоге с несколькими файлами и сравнение порядка результатов.

---

# Приложение A — runbook для подтверждения

> Команды здесь описывают **что нужно снять** как эталонные golden runs. Конкретные пути зависят от окружения.

## A.1. Help/version
```bash
chainsaw --help
chainsaw --version

chainsaw dump --help
chainsaw hunt --help
chainsaw lint --help
chainsaw search --help
chainsaw analyse --help
chainsaw analyse shimcache --help
chainsaw analyse srum --help
```

## A.2. Ошибки парсинга аргументов (exit code)
```bash
# неизвестная команда
chainsaw nope

# неизвестный флаг
chainsaw hunt --no-such-flag

# missing required args
chainsaw analyse srum --software SOFTWARE_ONLY
```

## A.3. Проверка минимального числа позиционных args
```bash
chainsaw dump
chainsaw hunt
chainsaw search
```
