# GOV-0002 — Критерии эквивалентности 1:1 и доказательная база приёмки

## Цель
Зафиксировать, что именно означает **эквивалентность 1:1** для порта Chainsaw на C++ в **проверяемых терминах** и какие артефакты составляют **доказательную базу приёмки**.

Документ определяет **критерии сравнения** и **правила доказательства**, но не подменяет собой As‑Is спецификации Rust (–14) и не делает To‑Be решений.

## Область действия
Критерии применяются ко всем целевым платформам проекта:
- Windows
- Linux
- macOS

И ко всем уровням проверки, предусмотренным планом:
- **test‑to‑test** (порт тестов Rust и/или эквивалентные проверки в C++),
- **golden runs** (эталонные прогоны Rust),
- **diff harness** (автоматическое сравнение Rust vs C++ по сценариям).

## Определения
- **Наблюдаемое поведение** — всё, что может наблюдать пользователь/интегратор при запуске бинарника:
 - код возврата (exit code);
 - stdout / stderr (как последовательность байт);
 - создаваемые/изменяемые файлы и их содержимое;
 - побочные эффекты, явно декларируемые CLI (например, создание отчёта по пути `--output`).
- **Сценарий запуска** (`RUN-*`) — воспроизводимое описание запуска (команда, аргументы, окружение, входные данные) + эталонные результаты.
- **Отчёт проверки/диффа** (`REP-*`) — артефакт, фиксирующий результат сравнения и, при необходимости, сохраняющий сырые материалы (stdout/stderr, файлы вывода, метаданные среды).

> Термины и схема ID: см. `docs/governance/GOV-0001-traceability-and-sot.md`.

---

## 1) Принципы сравнения (общие)

### 1.1. Базовый принцип 1:1
Для одинаковых:
- CLI аргументов,
- входных данных (включая байтовое содержимое файлов),
- конфигурации (если есть),
- релевантных переменных окружения,

C++ порт обязан воспроизводить **то же наблюдаемое поведение**, что и Rust Chainsaw.

### 1.2. Платформенная оговорка
**1:1 сравнение выполняется «внутри платформы».**

То есть:
- C++ на Windows сравнивается с Rust на Windows,
- C++ на Linux сравнивается с Rust на Linux,
- C++ на macOS сравнивается с Rust на macOS.

Допускается, что Rust сам может иметь платформенные отличия (например, в формулировках системных ошибок). Эти отличия считаются частью наблюдаемого поведения на конкретной платформе.

### 1.3. Управление окружением для воспроизводимости
Все эталонные прогоны (golden runs) и дифф‑сравнения обязаны фиксировать:
- ОС и версию,
- архитектуру (x86_64/arm64),
- версию компилятора/рантайма (Rust toolchain, C++ compiler),
- ключевые переменные окружения, влияющие на результат (минимум: `LANG/LC_ALL` на Unix, кодировка/локаль на Windows, `TZ`),
- текущий рабочий каталог (cwd) и относительные/абсолютные пути, используемые в сценарии.

**Если окружение не зафиксировано, результат сравнения не считается доказательством.**

---

## 2) Критерии эквивалентности 1:1 (проверяемые)

Ниже критерии сформулированы так, чтобы их можно было доказать через тесты/прогоны/дифф‑отчёты.

### C1. CLI‑контракт
**Что сравниваем:**
- набор команд/подкоманд;
- опции/флаги/позиционные аргументы;
- значения по умолчанию;
- валидацию аргументов;
- поведение `--help`/help‑страниц (если присутствует) и `--version` (если присутствует).

**Критерий:**
- для каждого задокументированного (As‑Is) CLI сценария код возврата и stdout/stderr совпадают с Rust;
- для неверных аргументов совпадают код возврата и формат/текст сообщения об ошибке.

**Доказательства:**
- As‑Is спецификация CLI + тесты на парсинг/валидацию (/32) + golden runs для `--help/--version` (/27).

### C2. Вывод в stdout/stderr
**Что сравниваем:**
- stdout и stderr **как байтовые потоки**, включая переводы строк, пробелы и порядок строк;
- отсутствие/наличие диагностических префиксов (например, `error:`) — как в Rust.

**Критерий:**
- для каждого сценария сравнения stdout/stderr совпадают с эталоном Rust;
- кодировка/представление текста считается частью вывода (проверяется байт‑в‑байт).

**Доказательства:**
- golden runs с сохранением сырых stdout/stderr + дифф‑отчёт (/33).

### C3. Коды возврата (exit codes)
**Что сравниваем:**
- exit code каждого сценария (успех, ошибки ввода, ошибки правил, ошибки чтения EVTX и т.д.).

**Критерий:**
- exit code совпадает с Rust для каждого сценария.

**Доказательства:**
- протоколы golden runs и/или тесты (/32) + дифф‑отчёты (/33).

### C4. Детекты/результаты анализа
**Что сравниваем:**
- «что считается детектом» для заданных EVTX/Sigma и параметров запуска;
- состав и значения полей, которые Chainsaw выводит/экспортирует для каждого детекта (например: правило/уровень/источник/временные метки/идентификаторы событий) — **в точности как в Rust**;
- порядок выдачи детектов, если он наблюдаем и стабилен в Rust.

**Критерий:**
- C++ возвращает тот же набор детектов и те же поля, что и Rust, в том же формате вывода;
- если Rust выводит детекты в определённом порядке — C++ сохраняет этот порядок.

**Доказательства:**
- эталонные прогоны Rust на фиксированных датасетах + дифф‑сравнение (/33);
- test‑to‑test проверки логики (/32).

### C5. Файлы вывода и побочные эффекты
**Что сравниваем:**
- наличие/отсутствие создаваемых файлов, их пути и содержимое;
- формат файлов (если есть экспорт JSON/CSV/отчёты) — байт‑в‑байт.

**Критерий:**
- набор файлов и их байтовое содержимое совпадают с Rust для каждого сценария;
- при ошибках файлы/артефакты создаются/не создаются так же, как в Rust.

**Доказательства:**
- golden runs с сохранением артефактов + дифф‑отчёты (/33).

### C6. Сообщения об ошибках
**Что сравниваем:**
- текст ошибок и его размещение (stdout vs stderr),
- формат (префиксы, строки, наличие подсказок),
- поведение при «тяжёлых»/битых входах (EVTX/Sigma),
- соответствие коду возврата.

**Критерий:**
- сообщения об ошибках совпадают с Rust (в пределах платформы) и сопровождаются теми же exit codes.

**Доказательства:**
- negative golden runs + тесты на ошибки (/32) + дифф‑отчёты (/33).

### C7. Детерминизм
**Что сравниваем:**
- стабильность stdout/stderr, exit code и файлов вывода при повторных запусках на одинаковых входах.

**Критерий:**
- для каждого выбранного сценария (минимум: ключевые e2e сценарии из /27) результаты Rust повторяемы;
- результаты C++ повторяемы;
- результаты C++ совпадают с Rust.

**Доказательства:**
- протокол повторных запусков (3+ повторения) как часть `RUN-*`/`REP-*`.

> Производительность/оптимизации не входят в критерии 1:1 и рассматриваются отдельно (–38).

---

## 3) Допустимые нормализации (по умолчанию: запрещены)

По умолчанию сравнение выполняется **строго байт‑в‑байт** для stdout/stderr и файлов вывода.

**Нормализация** (например: стабилизация путей, временных меток, сортировка вывода, приведение переводов строк) **запрещена**, пока не выполнены одновременно условия:
1) найдено и доказано (на фактах /13), что Rust выводит нестабильные/окружение‑зависимые поля;
2) нормализация описана как проверяемое правило (через отдельное решение `DEC-*` или `ADR-*`);
3) нормализация применяется **симметрично** к Rust и C++ в harness;
4) нормализация не скрывает реальные расхождения (в отчёте фиксируется, что именно нормализовано).

---

## 4) Доказательная база приёмки (какие артефакты нужны)

### 4.1. Классы доказательств
1) **As‑Is спецификации Rust** (–14)
 - CLI‑контракт,
 - реестр фич,
 - As‑Is архитектура,
 - форматы данных,
 - зависимости,
 - матрица тестов,
 - протоколы эталонных прогонов.

2) **Test‑to‑test база** (/32)
 - `TST-*` логические тесты и их реализации в Rust/C++,
 - отчёт выполнения тестов (локально/CI).

3) **Golden runs**
 - сценарии `RUN-*` + сохранённые stdout/stderr/exit code + выходные файлы.

4) **Diff harness отчёты** (/33)
 - `REP-*` отчёты «совпало/не совпало» по каждому сценарию,
 - при несовпадении — сохранение обеих сторон (Rust/C++) для анализа.

5) **Кроссплатформенные подтверждения**
 - CI‑логи сборки/тестов по матрице ОС,
 - e2e‑валидатор по платформам.

### 4.2. Минимальный набор для приёмки слайса (–33)
Слайс считается закрытым (UnitDone), если:
- определены `TST-*` и/или `RUN-*`, покрывающие наблюдаемое поведение слайса;
- пройдены тесты и дифф‑сравнения по критериям C1–C7 (в применимой части);
- отчёт `REP-*` зарегистрирован как артефакт и связан с `SLICE-*`.

### 4.3. Минимальный набор для итоговой приёмки parity
Parity считается достигнутым, если:
- все слайсы закрыты по UnitDone;
- выполнен parity‑аудит;
- нет регрессий относительно golden runs по выбранному покрытию;
- подтверждена кроссплатформенная сборка/тесты/е2e (/41) или оформлены исключения как риски.
