# DEC-0003 — Инструменты для сборки golden runs (Rust эталоны)

## Контекст
- Для доказательства эквивалентности 1:1 потребуется воспроизводимая база эталонных прогонов Rust (stdout/stderr/exit code) по ключевым сценариям.
- Эталонные прогоны должны сниматься на нескольких ОС (Windows/Linux/macOS) и храниться как артефакты Projects/CI.
- Для сравнения с C++ позже понадобится дифф‑harness, поэтому формат результатов должен быть стандартизирован.

## Решение
Использовать два уровня инструментов для сборки Rust golden runs:
1) `tools/golden_run_simple.py` — минимальный скрипт для запуска одного набора команд и сохранения stdout/stderr/exit code.
2) `tools/golden_runs_full/run_rust_golden_runs.py` + `tools/golden_runs_full/README.md` — полный воспроизводимый скрипт/протокол для серийного прогона сценариев `RUN-*` с сохранением метаданных среды (`env.json`, `build.json`, `manifest.json`) и упаковкой результатов.

## Альтернативы
A) Ручной запуск команд и копирование результатов.
- Минусы: высокая вероятность ошибок, отсутствие стандартизации и слабая воспроизводимость.

B) Сразу разрабатывать дифф‑harness и снимать эталоны через него.
- Минусы: до ещё нет инфраструктуры сравнения; нужно иметь эталоны заранее, чтобы потом валидировать harness.

## Обоснование выбора
- Два уровня скриптов позволяют:
 - быстро фиксировать локальные наблюдения (simple);
 - и одновременно иметь единый формат «эталонного набора» для дальнейших автоматизированных сравнений (full).

## Последствия
- Формат результатов `RUN-*` становится стандартом доказательств (в дополнение к Rust unit/integration tests).
- В репозитории хранятся только скрипты и протоколы; сами результаты хранятся как внешние артефакты.

## Критерии проверки/пересмотра
- Если появятся недетерминированные элементы вывода (см. RISK-0011), допускается расширение скриптов нормализацией только по отдельному решению (DEC/ADR) согласно GOV-0002.
