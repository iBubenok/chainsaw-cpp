# ADR-0009 — Стратегия парсеров форензик‑форматов (EVTX/ESEDB/HVE/MFT/XML)

## Статус
- Дата: 2026-01-02 (обновлено: 2026-01-13)
- Статус: Accepted

### Сводная таблица решений (2026-01-13)
| Формат | Решение | Строки кода | Обоснование |
|--------|---------|-------------|-------------|
| EVTX | Собственный парсер | 1,071 | libevtx не поддерживает `_attributes` |
| HVE/REGF | Собственный парсер | 1,604 | libregf alpha, нет transaction logs |
| MFT | Собственный парсер | 947 | libfsntfs не разделяет SI/FN timestamps |
| **ESEDB** | **Собственный парсер** | ~1,500-2,000 (план) | Кроссплатформенность, нет LGPL, консистентность |
| XML | pugixml + собственная конверсия | ~100 | Простой текстовый формат, полный контроль |
- Контекст To‑Be: `ARCH-0001`, `DATA-0001`, `DEPS-0001`, `ARCH-0002`
- Связанные требования: `REQ-FR-0002`, `REQ-FR-0004`, `REQ-FR-0005`, `REQ-FR-0006`, `REQ-FR-0007`, `REQ-NFR-0010`, `REQ-NFR-0012`, `REQ-SEC-0017`, `REQ-OPS-0028`
- Связанные риски: `RISK-0011`, `RISK-0022`, `RISK-0026`, `RISK-0032`

## Контекст
В baseline Chainsaw “документ” строится из сырого артефакта (EVTX/ESEDB/HVE/MFT/XML) и затем обрабатывается общим pipeline (см. `ARCH-0001`, `DATA-0001`).

Критические зависимости (As‑Is):
- EVTX: Rust crate `evtx` формирует JSON со структурой `_attributes` (`separate_json_attributes(true)`) — влияет на детекты (см. `DEPS-0001`).
- ESEDB (SRUM): `libesedb` (через Rust crate `libesedb`) — влияет на `analyse srum` и преобразования типов (см. `DEPS-0001`).
- HVE (Registry): Rust crate `notatin` (git) — влияет на `analyse shimcache` и восстановление через transaction logs (см. `DEPS-0001`).
- MFT: Rust crate `mft` (git) — влияет на побочные эффекты извлечения data streams и недетерминизм имён (`rand`) (см. `DEPS-0001`).
- XML: `quick-xml` для десериализации XML → JSON (см. `DEPS-0001`).

Матрица вариантов `ARCH-0002` (категория A1/A2) фиксирует, что для части форматов наиболее “приближённые к baseline” варианты — библиотеки семейства libyal, а для EVTX/XML — требуется отдельная оценка.

## Решение (стратегия)
1) Для форензик‑форматов применить принцип: **“минимизация расхождения с baseline через максимально близкий источник парсинга”**.

2) Для форматов, где baseline уже опирается на C/C++ парсер (например, `libesedb`), **использовать тот же парсер** в C++ порте (если интеграция кроссплатформенно реализуема через `ADR-0001/ADR-0002`).

3) Для форматов, где baseline использует чисто‑Rust реализацию (EVTX/HVE/MFT/XML), выбор C++ парсера считается **отложенным решением**, закрываемым через сравнение поведения по golden runs и/или через выделенные фикстуры.

## Статус по форматам (accepted/pending)
### ESEDB (SRUM) — Пересмотрено (2026-01-13)
- **Решение:** реализовать **собственный ESE парсер** на C++ (аналогично EVTX/HVE/MFT)
- **История решения:**
 - 2026-01-12: принято решение использовать libesedb
 - 2026-01-13: решение пересмотрено из-за проблемы Windows (RISK-ESEDB-WIN)
- **Обоснование пересмотра (2026-01-13):**
 - libesedb не работает на Windows без MSYS2/MinGW (сложность интеграции)
 - SRUM — Windows-артефакт, `analyse srum` должен работать на Windows
 - Консистентность: все остальные парсеры (EVTX, HVE, MFT) — собственные
 - Лицензия: libesedb — LGPL-3.0, собственный парсер — нет ограничений
 - Референс: [go-ese](https://github.com/Velocidex/go-ese) (~2,500 строк Go)
- **Оценка сложности:**
 | Компонент | Оценка строк | Описание |
 |-----------|--------------|----------|
 | Page parsing | ~300 | B+ tree navigation, page types |
 | Catalog | ~500 | MSysObjects, метаданные таблиц |
 | Table extraction | ~400 | Чтение записей, типы колонок |
 | Long values | ~200 | Long Value pages |
 | Compression | ~100 | LZXPRESS (опционально) |
 | **Итого** | **~1,500-2,000** | Сопоставимо с HVE (1,604) |
- **План реализации:**
 - Убрать условную компиляцию `CHAINSAW_HAVE_LIBESEDB`
 - Реализовать собственный парсер в `cpp/src/io/esedb.cpp`
 - API остаётся прежним (EsedbParser, EsedbIterator)
 - Референс: go-ese + libesedb documentation
- **Тесты:** существующие 21 unit-тест (TST-ESEDB-001..017) останутся без изменений
- **Целевая платформенная поддержка:**
 | Платформа | Статус | Примечание |
 |-----------|--------|------------|
 | Linux | ✅ Будет работать | Собственная реализация |
 | macOS | ✅ Будет работать | Собственная реализация |
 | Windows | ✅ Будет работать | Собственная реализация |
- **Риски:**
 - RISK-ESEDB-WIN: Mitigated (решение принято)
 - Новые риски: edge cases в B+ tree navigation, различные версии формата

### EVTX — Accepted (2026-01-10)
- **Решение:** собственная реализация Binary XML парсера на C++ (evtx.cpp)
- **Обоснование:**
 - `libevtx` не поддерживает `_attributes` разделение (критично для детектов)
 - Собственная реализация обеспечивает полный контроль над JSON структурой
 - Соответствие `separate_json_attributes(true)` семантике Rust crate `evtx`
- **Реализация:**
 - `cpp/include/chainsaw/evtx.hpp` — API парсера (EvtxParser, EvtxRecord)
 - `cpp/src/io/evtx.cpp` — полная реализация Binary XML формата (1,071 строк)
 - Интеграция с Reader framework через EvtxReader
- **Тесты:** unit-тесты SLICE-007
- **Верификация:** тесты проходят на 3 платформах (Linux/macOS/Windows)
- **Связанные документы:** SPEC-SLICE-007-evtx-parser.md

### HVE (Registry) / shimcache — Accepted (2026-01-12)
- **Решение:** собственная реализация REGF парсера на C++ (hve.cpp)
- **Обоснование:**
 - `libregf` находится в alpha состоянии и не поддерживает transaction logs
 - `windows-hive-parser` (C#) также не поддерживает transaction logs
 - Собственная реализация на основе документации libyal обеспечивает полный контроль
- **Transaction Log Support:** полностью поддерживается (2026-01-12)
 - Поиск.LOG,.LOG1,.LOG2 файлов в директории hive
 - Парсинг HVLE формата (HvLE signature, LogEntry, DirtyPageRef)
 - Применение dirty pages к hive buffer с проверкой sequence numbers
 - Соответствует поведению Rust baseline (notatin crate)
- **Реализация:**
 - `cpp/include/chainsaw/hve.hpp` — API парсера (HveParser, RegKey, RegValue)
 - `cpp/src/io/hve.cpp` — полная реализация REGF формата + transaction logs (~1200 строк)
 - Интеграция с Reader framework через HveReader
- **Тесты:** 19 unit-тестов (TST-HVE-001..015 + 4 дополнительных)
- **Верификация:** 382/382 тестов на Linux/macOS/Windows

### MFT — Accepted (2026-01-12)
- **Решение:** собственная реализация MFT парсера на C++ (аналогично HVE)
- **Обоснование (spike libfsntfs 2026-01-12):**
 - libfsntfs установлена и протестирована на Linux (v20240501)
 - **Критическое несоответствие:** libfsntfs НЕ разделяет StandardInfo и FileName timestamps
 - Rust `mft` crate выводит отдельно `StandardInfoLastModified`/`FileNameLastModified` и т.д.
 - libfsntfs возвращает единый набор timestamps без указания источника (SI vs FN)
 - **Отсутствующие поля в libfsntfs API:**
 - `Signature` ("FILE"/"BAAD") — нет прямого API
 - `HardLinkCount` — нет API
 - `UsedEntrySize`, `TotalEntrySize` — нет API
 - `Flags` (MFT entry flags) — нет API (только file_attribute_flags)
 - **macOS:** libfsntfs отсутствует в Homebrew, требуется сборка из исходников
- **Вывод spike:** libfsntfs не позволяет достичь 1:1 совместимости с JSON структурой Rust mft crate
- **Решение:** собственный парсер MFT на основе документации формата
 - MFT формат хорошо документирован (Microsoft + libyal)
 - Полный контроль над JSON структурой `FlatMftEntryWithName`
 - Явное разделение SI/FN timestamps
 - Кроссплатформенность без внешних зависимостей
- **Ожидаемая реализация:**
 - `cpp/include/chainsaw/mft.hpp` — API парсера (MftParser, MftEntry, DataStream)
 - `cpp/src/io/mft.cpp` — парсинг FILE records, атрибутов SI/FN/DATA
 - Интеграция с Reader framework
- **Риски:** RISK-MFT-001..004
- **Связанные документы:** SPEC-SLICE-018-mft-parser.md

### XML — Accepted (2026-01-12)
- **Решение:** pugixml (библиотека) + собственная конверсия XML→JSON
- **Обоснование (аудит 2026-01-12):**
 - Rust Chainsaw использует `quick_xml::de::from_reader` для десериализации XML в JSON
 - Реализация очень простая (~50 строк Rust): `quick_xml::de::from_reader(reader)` → `serde_json::Value`
 - XML не является сложным бинарным форматом — это текстовый формат с известной структурой
 - Собственная конверсия обеспечивает полный контроль над JSON структурой
- **Реализация (уже выполнена):**
 - `cpp/src/io/reader.cpp` — XmlReader класс с `xml_node_to_value` (~100 строк)
 - pugixml для парсинга XML (MIT лицензия, header-only опционально)
 - Собственная конверсия XML→JSON с правилами:
 - XML элемент → JSON объект
 - Атрибуты → поля с префиксом `@`
 - Текстовое содержимое → поле `$text`
 - Повторяющиеся элементы → массив
- **Тесты:** TST-XML-001..008 в test_reader_gtest.cpp
- **Верификация:** тесты проходят на 3 платформах (Linux/macOS/Windows)
- **Примечание:** golden runs для XML отсутствуют в upstream (RISK-0026 остаётся открытым)

## Обоснование
- Парсер формата определяет структуру “документа”, а значит непосредственно влияет на детекты/фильтры и 1:1 (см. `DATA-0001`, `GOV-0002`).
- Для ESEDB использование того же базового парсера, что и в Rust, минимизирует расхождение.
- Для EVTX/HVE/MFT/XML выбор без доказательств слишком рискован; поэтому решение фиксируется как pending с измеримыми критериями и источниками данных.

## Последствия
- В To‑Be архитектуре парсеры должны быть оформлены как сменяемые компоненты с единым “документным” интерфейсом.
- Для pending‑форматов требуется план “spike → сравнение → фиксация решения” до начала массового портирования соответствующих фич.

## План верификации
- /33: сравнение `search/hunt/analyse srum` на golden runs подтверждает корректность выбранных/интегрированных парсеров.
- –33 (цикл слайсов): выделить слайсы для EVTX‑парсинга и SRUM (в зависимости от приоритетов backlog) и закрыть pending решения экспериментами.

## Условия пересмотра
- Если интеграция libesedb или любой другой выбранной библиотеки окажется несовместимой с кроссплатформенной сборкой или офлайн‑режимом.
- Если будет принят иной юридический/лицензионный режим поставки, ограничивающий использование конкретных библиотек.
