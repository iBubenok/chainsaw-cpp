# ADR-0011 — Параллелизм и детерминизм результата

## Статус
- Дата: 2026-01-02
- Статус: Accepted
- Контекст To‑Be: `AR-0001`, `GOV-0002`, `ARCH-0001`, `DEPS-0001`
- Связанные требования: `REQ-NFR-0010`, `REQ-NFR-0015`, `REQ-NFR-0016`, `REQ-SEC-0017`
- Связанные риски: `RISK-0011`

## Контекст
Baseline Chainsaw использует `rayon` для параллельного обхода/обработки данных в некоторых ветках (см. `DEPS-0001`). Параллелизм потенциально влияет на:
- порядок выдачи событий/строк;
- порядок перечисления файлов/результатов;
- воспроизводимость stdout/stderr.

Требование 1:1 предъявляет строгие ожидания по детерминизму вывода (`REQ-NFR-0015`, `REQ-NFR-0016`).

## Решение
1) **Детерминизм важнее параллелизма** до тех пор, пока не доказано обратное.

2) В C++ порте разрешён параллелизм только при соблюдении условия:
- параллельное выполнение не должно менять наблюдаемый порядок и формат вывода.

Практически это означает:
- вычисления/парсинг могут выполняться параллельно;
- перед записью результатов во внешний вывод применяется стабильное упорядочивание (sort/group) по детерминированному ключу, если порядок наблюдаем.

3) На ранних этапах реализации (+ и первые слайсы) допускается реализация без параллелизма, если это снижает риск несоответствий. Параллелизация — отдельная оптимизационная задача с обязательной доказательной базой.

## Альтернативы
A) Полная имитация `rayon` (параллелить “как в Rust”)
- Плюсы: потенциальное совпадение производительности.
- Минусы: порядок выполнения задач в thread pool не гарантирован; даже при совпадении результатов возрастает риск недетерминизма.

B) Агрессивная параллелизация “везде”
- Плюсы: максимальная производительность.
- Минусы: противоречит требованиям по детерминизму; усложняет отладку и доказательство 1:1.

## Обоснование
- Основная цель проекта — 1:1 эквивалентность, а не оптимизация.
- Детерминизм снижает стоимость дифф‑анализа и предотвращает “ложные” расхождения.
- Решение напрямую снижает риск `RISK-0011`.

## Последствия
- В To‑Be архитектуре нужно явно выделить границу: где допускается параллелизм и где происходит детерминизация (например, на уровне “writer/aggregation layer”).
- Любая будущая оптимизация параллелизма должна сопровождаться тестами стабильности результатов (повторяемые прогоны).

## План верификации
- /33: повторные прогоны одних и тех же сценариев (несколько запусков подряд) должны давать идентичный stdout/stderr и отчёты diff‑harness.
- –33: отдельные тесты/прогоны на стабильность порядка (например, “вывести N результатов 10 раз → идентичность”).

## Условия пересмотра
- Если доказано, что baseline Rust сам по себе недетерминирован в конкретной ветке (зафиксировано в golden runs), и критерии эквивалентности допускают нормализацию порядка.
- Если детерминизация (sort/group) приводит к недопустимой деградации `REQ-NFR-0010`, и при этом есть способ сохранить наблюдаемый порядок без сортировки (например, стабильное разбиение входа).
