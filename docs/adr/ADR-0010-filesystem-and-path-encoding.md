# ADR-0010 — Файловая система, пути и кодировки (std::filesystem + единая политика преобразований)

## Статус
- Дата: 2026-01-02
- Статус: Accepted
- Контекст To‑Be: `AR-0001`, `DATA-0001`, `GOV-0002`, `ARCH-0001`
- Связанные требования: `REQ-NFR-0012`, `REQ-NFR-0015`, `REQ-NFR-0016`, `REQ-SEC-0017`, `REQ-OPS-0028`
- Связанные риски: `RISK-0007`, `RISK-0011`

## Контекст
Baseline Chainsaw активно работает с путями:
- обходит директории (`walkdir`),
- склеивает/нормализует пути (в том числе абсолютные/относительные),
- печатает пути в stdout/stderr и включает их в JSON/YAML вывод.

На разных ОС “нативные” представления путей различаются (Windows UTF‑16, Unix произвольные bytes). При этом требования 1:1 оценивают байтовый вывод (`REQ-NFR-0016`) и воспроизводимость (`REQ-NFR-0015`).

## Решение
1) Использовать `std::filesystem::path` как единый тип для путей во всём C++ порте.

2) Ввести единый слой преобразований «путь ⇄ строка»:
- **Внутреннее текстовое представление** (для JSON/YAML, логических полей документа): UTF‑8 (`std::string`).
- **Преобразование входных аргументов CLI → path**: принимать UTF‑8 и создавать `std::filesystem::path` с учётом платформы.
- **Преобразование path → строка для пользовательского вывода**: выполнять явное преобразование в UTF‑8. Для некорректных последовательностей на Unix применять замену символов (lossy), чтобы избежать падений и иметь предсказуемое поведение.

3) Для детерминизма:
- не полагаться на порядок перечисления файловой системы;
- если порядок наблюдаем (в выводе/JSON), сортировать по стабильному ключу (например, по отображаемой строке пути).

## Альтернативы
A) Boost.Filesystem
- Плюсы: исторически зрелая реализация, широкая поддержка.
- Минусы: тяжёлая зависимость (противоречит минимизации поверхности и `ADR-0002`), сложнее офлайн‑вендоринг.

B) Самописные обёртки поверх OS API
- Плюсы: полный контроль.
- Минусы: высокий риск ошибок и регрессий, большой объём кода, сложно поддерживать на 3 ОС.

## Обоснование
- `std::filesystem` доступен в базовом стандарте C++17, выбранном в `ADR-0001`.
- Единый слой преобразований уменьшает риск “случайных” отличий в представлении путей в разных местах кода.
- Явная политика lossy‑преобразований позволяет безопасно обрабатывать недоверенные имена файлов (`REQ-SEC-0017`) без неопределённого поведения.

## Последствия
- В To‑Be архитектуре должен появиться модуль/утилита (например, `platform::paths`), который является единственной точкой преобразования путей.
- Все места, где путь попадает в stdout/stderr/JSON, используют этот слой.

## План верификации
- /33: дифф‑сравнение сценариев, где путь наблюдаем (как минимум кейсы с пробелами/спецсимволами; см. `RISK-0007`).
- –33: добавить unit‑тесты на преобразования `path ⇄ string` для Windows и Unix‑семантик (в т.ч. не‑UTF8 байты на Unix через фикстуры).

## Условия пересмотра
- Если конкретная реализация `std::filesystem` в целевых toolchain не обеспечивает стабильного поведения (например, баги в `u8path`/`u8string`).
- Если baseline Rust наблюдаемо ведёт себя иначе на не‑UTF8 путях и это подтверждено golden runs.
