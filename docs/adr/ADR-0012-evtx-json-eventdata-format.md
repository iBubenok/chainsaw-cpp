# ADR-0012 — Формат JSON EventData в EVTX парсере (GAP-001)

## Статус
- Дата: 2026-01-15
- Статус: **Implemented**
- Связанные риски: RISK-0040 (GAP-001) — **CLOSED**
- Связанные требования: REQ-NFR-0010, REQ-FR-0002, REQ-FR-0003

### Реализация
- `cpp/src/io/evtx.cpp`: `is_event_data_container`, `convert_event_data_node`
- `cpp/src/io/reader.cpp`: аналогичная flatten логика для XML reader
- Тесты: TST-DET-001..003 (determinism), TST-ROB-* (robustness)
- Результаты: 505/505 PASS на 3 платформах + ASan/UBSan

## Контекст

После parity-аудита обнаружено расхождение в формате JSON вывода EventData:

**Rust (upstream):**
```json
{"EventData": {"SubjectUserSid": "S-1-5-18", "SubjectUserName": "SYSTEM",...}}
```

**C++ (текущий):**
```json
{"EventData": {"Data": [{"$text": "S-1-5-18", "Data_attributes": {"Name": "SubjectUserSid"}},...]}}
```

### Причина расхождения

Rust crate `evtx` использует `separate_json_attributes(true)`, что генерирует:
- Плоскую структуру EventData с парами `FieldName: Value`
- Атрибуты элементов выносятся в `_attributes` только для элементов с атрибутами, не для значений

C++ парсер (evtx.cpp) генерирует:
- Вложенную структуру с массивом `Data`
- Каждый элемент содержит `$text` и `Data_attributes`

### Влияние

1. **Byte-to-byte сравнение stdout** — не проходит
2. **Chainsaw rules** — пути `Event.EventData.<FieldName>` не работают
3. **Sigma rules** — используют mappings, могут потребовать адаптации

## Варианты решения

### Вариант A: Flatten на уровне парсера (Recommended)
Изменить evtx.cpp для генерации плоской структуры EventData.

**Плюсы:**
- Byte-to-byte совместимость с upstream
- Существующие правила работают без изменений
- Соответствует GOV-0002 (критерий C2)

**Минусы:**
- Требует изменений в evtx.cpp
- Потеря информации об атрибутах (если есть)

### Вариант B: Mapping на уровне rules
Адаптировать tau engine для поддержки обеих структур.

**Плюсы:**
- Не требует изменений парсера
- Сохраняет полную информацию о структуре XML

**Минусы:**
- Нарушает byte-to-byte совместимость
- Усложняет tau engine
- Требует модификации правил

### Вариант C: Двойной режим
Добавить флаг `--json-format=flat|structured`.

**Плюсы:**
- Гибкость для пользователей

**Минусы:**
- Усложняет интерфейс
- Не соответствует 1:1 (новая функциональность)
- Противоречит REQ-NFR-0016

## Решение

**Принят вариант A: Flatten на уровне парсера.**

### Обоснование

1. **GOV-0002 требует byte-to-byte совместимость** — критерий C2 явно указывает на сравнение stdout как байтовых потоков
2. **Существующие правила** — Chainsaw и Sigma правила рассчитаны на плоскую структуру upstream
3. **Минимальные изменения** — изменения локализованы в evtx.cpp, не затрагивают tau engine
4. **Принцип "не улучшать"** — REQ-NFR-0016 запрещает изменения форматов без управляемого решения

### Детали реализации

**Текущая логика в evtx.cpp:**
```cpp
// Формирует: {"Data": [{"$text": "value", "Data_attributes": {"Name": "field"}}]}
```

**Требуемая логика:**
```cpp
// Формировать: {"FieldName": "value", "AnotherField": "another_value"}
// Для элементов с одинаковыми Name — массив значений
```

**Алгоритм flatten:**
1. Для каждого элемента `<Data Name="X">value</Data>`:
 - Извлечь атрибут `Name` как ключ
 - Значение элемента как значение
2. Если несколько элементов с одинаковым Name:
 - Создать массив значений
3. Для элементов без Name:
 - Использовать tag name как ключ

### Затрагиваемые файлы

| Файл | Изменение |
|------|-----------|
| `cpp/src/io/evtx.cpp` | Flatten логика для EventData |
| `cpp/tests/test_evtx_gtest.cpp` | Обновить expected JSON |

### Тесты

1. **Существующие тесты** — обновить expected output
2. **Новые тесты** — TST-GAP-001..003 из TEST-EXPAND-0001
3. **Golden runs** — должны пройти byte-to-byte

## Последствия

1. **evtx.cpp** требует модификации функции конверсии EventData
2. **Unit-тесты** для EVTX требуют обновления expected values
3. **RISK-0040** будет закрыт после реализации

## План верификации

1. Реализовать flatten логику в evtx.cpp
2. Обновить unit-тесты
3. Прогнать golden runs сравнение
4. Подтвердить byte-to-byte совместимость

## Условия пересмотра

- Если обнаружатся upstream правила, зависящие от structured формата
- Если потеря информации об атрибутах окажется критичной для каких-либо сценариев

