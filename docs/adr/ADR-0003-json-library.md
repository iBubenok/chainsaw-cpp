# ADR-0003 — Библиотека JSON (парсинг и генерация вывода)

## Статус
- Дата: 2026-01-02
- Статус: Accepted
- Контекст To‑Be: `TASK-0001`, `AR-0001`, `ARCH-0002`
- Связанные требования: `REQ-FR-0002`, `REQ-FR-0008`, `REQ-NFR-0010`, `REQ-NFR-0015`, `REQ-NFR-0016`, `REQ-SEC-0017`, `REQ-OPS-0028`
- Связанные риски: `RISK-0011`, `RISK-0030`

## Контекст
JSON является ключевым форматом для:
- вывода `dump` и частей `search/hunt` (см. `FEAT-0001`, `DATA-0001`);
- представления документов EVTX/ESEDB/XML в конвейере (см. `ARCH-0001`, `DEPS-0001`).

Golden runs фиксируют stdout/stderr как bytes (см. `REP-0001`), поэтому критична детерминированность сериализации (пробелы, переводы строк, порядок ключей) и воспроизводимость поведения на одинаковых входах.

Матрица вариантов `ARCH-0002` (категория B2) рассматривает альтернативы: RapidJSON, nlohmann/json, Boost.JSON, simdjson.

## Решение
1) Принять **RapidJSON** как базовую библиотеку для:
 - JSON DOM (парсинг документов/правил в JSON при необходимости);
 - потоковой генерации JSON/JSONL вывода через `Writer`.

2) Сериализация, влияющая на 1:1, считается частью логики порта:
 - форматирование (whitespace/newlines) и порядок полей задаются кодом порта, а не «дефолтами» библиотеки;
 - при необходимости вводится явная каноникализация (например, сортировка ключей) так, чтобы совпадать с baseline Rust по `GOV-0002` и golden runs.

3) Безопасность и устойчивость:
 - входные JSON рассматриваются как недоверенные (`REQ-SEC-0017`);
 - парсер должен иметь ограничения по глубине/размеру; конкретные лимиты фиксируются в реализации и в developer guide.

## Альтернативы
A) nlohmann/json
- Плюсы: header-only, простой API.
- Минусы: менее удобен для потоковой генерации без лишних аллокаций; «умолчания» по форматированию и порядок ключей требуют дополнительного контроля.

B) Boost.JSON
- Плюсы: часть Boost, хорошая производительность.
- Минусы: зависимость на Boost (увеличение поверхности/веса), усложнение vendoring.

C) simdjson
- Плюсы: высокая скорость парсинга.
- Минусы: фокус на парсинг; для сериализации всё равно нужен отдельный компонент.

## Обоснование
- RapidJSON обеспечивает комбинацию DOM + streaming writer, позволяя строго контролировать байтовый вывод (`REQ-NFR-0015`, `REQ-NFR-0016`).
- Библиотека подходит для режима JSONL и больших потоков данных без необходимости держать всё в памяти (`REQ-NFR-0010`).
- Уменьшается риск несоответствия из‑за «скрытых» локалей/форматов при использовании iostream (см. `REQ-NFR-0015`).

## Последствия
- В To‑Be архитектуре должен появиться слой‑обёртка `json` (или эквивалент) с едиными правилами сериализации/парсинга.
- Выбор RapidJSON должен быть отражён в реестре лицензий C++‑зависимостей (`LIC-0002`) и реализован через стратегию `ADR-0002`.

## План верификации
- /33: дифф‑сравнение JSON/JSONL выводов по сценариям `*`, `*`, `*`, `*` согласно `GOV-0002`.
-: перенос/эквивалентные тесты `TST-*`, которые завязаны на JSON структуры (см. `TESTMAT-0001`).

## Условия пересмотра
- Если невозможность воспроизвести байтовое форматирование/порядок полей будет доказана diff‑harness (при корректной реализации) и подтвердится как системное ограничение библиотеки.
- Если профиль производительности/памяти на реальных данных приведёт к невозможности соблюсти `REQ-NFR-0010` без замены библиотеки.
